
// ========== lib/pose_detection_tflite.dart ==========

     1	library pose_detection_tflite;
     2	
     3	export 'src/types.dart';
     4	export 'src/pose_detector.dart' show PoseDetector, PoseOptions, PoseMode;

// ========== lib/src/dart_registration.dart ==========

     1	// Stub for Flutter plugin parity; no-op in pure Dart.
     2	void registerWith() {}

// ========== lib/src/image_utils.dart ==========

     1	import 'dart:math' as math;
     2	import 'package:image/image.dart' as img;
     3	
     4	class ImageUtils {
     5	  static img.Image letterbox(
     6	      img.Image src,
     7	      int tw,
     8	      int th,
     9	      List<double> ratioOut,
    10	      List<int> dwdhOut,
    11	      ) {
    12	    final w = src.width;
    13	    final h = src.height;
    14	    final r = math.min(th / h, tw / w);
    15	    final nw = (w * r).round();
    16	    final nh = (h * r).round();
    17	    final dw = (tw - nw) ~/ 2;
    18	    final dh = (th - nh) ~/ 2;
    19	
    20	    final resized = img.copyResize(
    21	      src,
    22	      width: nw,
    23	      height: nh,
    24	      interpolation: img.Interpolation.linear,
    25	    );
    26	    final canvas = img.Image(width: tw, height: th);
    27	    img.fill(canvas, color: img.ColorRgb8(114, 114, 114));
    28	    img.compositeImage(canvas, resized, dstX: dw, dstY: dh);
    29	
    30	    ratioOut..clear()..add(r);
    31	    dwdhOut..clear()..addAll([dw, dh]);
    32	    return canvas;
    33	  }
    34	
    35	  static img.Image letterbox256(
    36	      img.Image src,
    37	      List<double> ratioOut,
    38	      List<int> dwdhOut,
    39	      ) {
    40	    return letterbox(src, 256, 256, ratioOut, dwdhOut);
    41	  }
    42	
    43	  static List<double> scaleFromLetterbox(
    44	      List<double> xyxy,
    45	      double ratio,
    46	      int dw,
    47	      int dh,
    48	      ) {
    49	    final x1 = (xyxy[0] - dw) / ratio;
    50	    final y1 = (xyxy[1] - dh) / ratio;
    51	    final x2 = (xyxy[2] - dw) / ratio;
    52	    final y2 = (xyxy[3] - dh) / ratio;
    53	    return [x1, y1, x2, y2];
    54	  }
    55	
    56	  static List<List<List<List<double>>>> imageToNHWC4D(
    57	      img.Image image,
    58	      int width,
    59	      int height, {
    60	        List<List<List<List<double>>>>? reuse,
    61	      }) {
    62	    final out = reuse ??
    63	        List.generate(
    64	          1,
    65	              (_) => List.generate(
    66	            height,
    67	                (_) => List.generate(
    68	              width,
    69	                  (_) => List<double>.filled(3, 0.0),
    70	              growable: false,
    71	            ),
    72	            growable: false,
    73	          ),
    74	          growable: false,
    75	        );
    76	
    77	    for (int y = 0; y < height; y++) {
    78	      for (int x = 0; x < width; x++) {
    79	        final px = image.getPixel(x, y);
    80	        out[0][y][x][0] = px.r / 255.0;
    81	        out[0][y][x][1] = px.g / 255.0;
    82	        out[0][y][x][2] = px.b / 255.0;
    83	      }
    84	    }
    85	    return out;
    86	  }
    87	
    88	  static List<List<List<List<double>>>> reshapeToTensor4D(
    89	      List<double> flat,
    90	      int dim1,
    91	      int dim2,
    92	      int dim3,
    93	      int dim4,
    94	      ) {
    95	    final result = List.generate(
    96	      dim1,
    97	          (_) => List.generate(
    98	        dim2,
    99	            (_) => List.generate(
   100	          dim3,
   101	              (_) => List<double>.filled(dim4, 0.0),
   102	        ),
   103	      ),
   104	    );
   105	
   106	    int index = 0;
   107	    for (int i = 0; i < dim1; i++) {
   108	      for (int j = 0; j < dim2; j++) {
   109	        for (int k = 0; k < dim3; k++) {
   110	          for (int l = 0; l < dim4; l++) {
   111	            result[i][j][k][l] = flat[index++];
   112	          }
   113	        }
   114	      }
   115	    }
   116	
   117	    return result;
   118	  }
   119	}

// ========== lib/src/person_detector.dart ==========

     1	import 'dart:math' as math;
     2	import 'package:image/image.dart' as img;
     3	import 'package:tflite_flutter_custom/tflite_flutter.dart';
     4	import 'image_utils.dart';
     5	
     6	class YoloDetection {
     7	  final int cls;
     8	  final double score;
     9	  final List<double> bboxXYXY;
    10	
    11	  YoloDetection({
    12	    required this.cls,
    13	    required this.score,
    14	    required this.bboxXYXY,
    15	  });
    16	}
    17	
    18	class YoloV8PersonDetector {
    19	  static const int cocoPersonClassId = 0;
    20	
    21	  Interpreter? _interpreter;
    22	  bool _isInitialized = false;
    23	
    24	  late int _inW;
    25	  late int _inH;
    26	
    27	  final _outShapes = <List<int>>[];
    28	
    29	  List<List<List<List<double>>>>? _inputBuffer;
    30	  Map<int, Object>? _outputBuffers;
    31	
    32	  Future<void> initialize() async {
    33	    const assetPath = 'packages/pose_detection_tflite/assets/models/yolov8n_float32.tflite';
    34	    if (_isInitialized) await dispose();
    35	    _interpreter = await Interpreter.fromAsset(assetPath);
    36	    _interpreter!.allocateTensors();
    37	
    38	    final inTensor = _interpreter!.getInputTensor(0);
    39	    final inShape = inTensor.shape;
    40	    _inH = inShape[1];
    41	    _inW = inShape[2];
    42	
    43	    _outShapes.clear();
    44	    final outs = _interpreter!.getOutputTensors();
    45	    for (final t in outs) {
    46	      _outShapes.add(List<int>.from(t.shape));
    47	    }
    48	
    49	    _isInitialized = true;
    50	  }
    51	
    52	  bool get isInitialized => _isInitialized;
    53	
    54	  Future<void> dispose() async {
    55	    _interpreter?.close();
    56	    _interpreter = null;
    57	    _inputBuffer = null;
    58	    _outputBuffers = null;
    59	    _isInitialized = false;
    60	  }
    61	
    62	  static double _sigmoid(double x) => 1.0 / (1.0 + math.exp(-x));
    63	
    64	  static List<int> _argSortDesc(List<double> a) {
    65	    final idx = List<int>.generate(a.length, (i) => i);
    66	    idx.sort((i, j) => a[j].compareTo(a[i]));
    67	    return idx;
    68	  }
    69	
    70	  static List<int> _nms(
    71	      List<List<double>> boxes,
    72	      List<double> scores, {
    73	        double iouThres = 0.45,
    74	        int maxDet = 100,
    75	      }) {
    76	    if (boxes.isEmpty) return <int>[];
    77	    final order = _argSortDesc(scores);
    78	    final keep = <int>[];
    79	
    80	    double interArea(List<double> a, List<double> b) {
    81	      final xx1 = math.max(a[0], b[0]);
    82	      final yy1 = math.max(a[1], b[1]);
    83	      final xx2 = math.min(a[2], b[2]);
    84	      final yy2 = math.min(a[3], b[3]);
    85	      final w = math.max(0.0, xx2 - xx1);
    86	      final h = math.max(0.0, yy2 - yy1);
    87	      return w * h;
    88	    }
    89	
    90	    double area(List<double> b) => math.max(0.0, b[2] - b[0]) * math.max(0.0, b[3] - b[1]);
    91	    final areas = boxes.map(area).toList();
    92	
    93	    final suppressed = List<bool>.filled(order.length, false);
    94	    for (int m = 0; m < order.length; m++) {
    95	      if (suppressed[m]) continue;
    96	      final i = order[m];
    97	      keep.add(i);
    98	      if (keep.length >= maxDet) break;
    99	      for (int n = m + 1; n < order.length; n++) {
   100	        if (suppressed[n]) continue;
   101	        final j = order[n];
   102	        final inter = interArea(boxes[i], boxes[j]);
   103	        final u = areas[i] + areas[j] - inter + 1e-7;
   104	        final iou = inter / u;
   105	        if (iou > iouThres) suppressed[n] = true;
   106	      }
   107	    }
   108	    return keep;
   109	  }
   110	
   111	  static List<List<double>> _transpose2D(List<List<double>> a) {
   112	    if (a.isEmpty) return <List<double>>[];
   113	    final rows = a.length, cols = a[0].length;
   114	    final out = List.generate(cols, (_) => List<double>.filled(rows, 0.0));
   115	    for (int r = 0; r < rows; r++) {
   116	      final row = a[r];
   117	      for (int c = 0; c < cols; c++) {
   118	        out[c][r] = row[c];
   119	      }
   120	    }
   121	    return out;
   122	  }
   123	
   124	  static List<List<double>> _concat0(List<List<List<double>>> parts) {
   125	    final out = <List<double>>[];
   126	    for (final p in parts) {
   127	      out.addAll(p);
   128	    }
   129	    return out;
   130	  }
   131	
   132	  static List<List<double>> _ensure2D(List<dynamic> raw) {
   133	    return raw.map<List<double>>((e) => (e as List).map((v) => (v as num).toDouble()).toList()).toList();
   134	  }
   135	
   136	  List<Map<String, dynamic>> _decodeAnyYoloOutputs(List<dynamic> outputs) {
   137	    final parts = <List<List<double>>>[];
   138	    for (final raw in outputs) {
   139	      final t3d = raw as List;
   140	      if (t3d.length != 1) throw StateError('Unexpected YOLO output rank');
   141	      final out2d = _ensure2D(t3d[0]);
   142	      if (out2d.isEmpty) continue;
   143	      final rows = out2d.length;
   144	      final cols = out2d[0].length;
   145	      if (rows < cols && (rows == 84 || rows == 85)) {
   146	        parts.add(_transpose2D(out2d));
   147	      } else {
   148	        parts.add(out2d);
   149	      }
   150	    }
   151	    final out = _concat0(parts);
   152	    if (out.isEmpty || out[0].length < 84) throw StateError('Expected channels >=84');
   153	    final channels = out[0].length;
   154	    return out
   155	        .map((row) => {
   156	      'xywh': row.sublist(0, 4),
   157	      'rest': row.sublist(4),
   158	      'C': channels,
   159	    })
   160	        .toList();
   161	  }
   162	
   163	  static List<double> _xywhToXyxy(List<double> xywh) {
   164	    final cx = xywh[0], cy = xywh[1], w = xywh[2], h = xywh[3];
   165	    return [cx - w / 2.0, cy - h / 2.0, cx + w / 2.0, cy + h / 2.0];
   166	  }
   167	
   168	  static double _median(List<double> a) {
   169	    if (a.isEmpty) return double.nan;
   170	    final b = List<double>.from(a)..sort();
   171	    final n = b.length;
   172	    if (n.isOdd) return b[n ~/ 2];
   173	    return 0.5 * (b[n ~/ 2 - 1] + b[n ~/ 2]);
   174	  }
   175	
   176	  List<YoloDetection> detectOnImage(
   177	      img.Image image, {
   178	        double confThres = 0.35,
   179	        double iouThres = 0.4,
   180	        int topkPreNms = 100,
   181	        int maxDet = 10,
   182	        bool personOnly = true,
   183	      }) {
   184	    if (!_isInitialized || _interpreter == null) {
   185	      throw StateError('YoloV8PersonDetector not initialized.');
   186	    }
   187	
   188	    final ratio = <double>[];
   189	    final dwdh = <int>[];
   190	    final letter = ImageUtils.letterbox(image, _inW, _inH, ratio, dwdh);
   191	    final r = ratio.first;
   192	    final dw = dwdh[0], dh = dwdh[1];
   193	
   194	    if (_inputBuffer == null) {
   195	      _inputBuffer = List.generate(
   196	        1,
   197	            (_) => List.generate(
   198	          _inH,
   199	              (_) => List.generate(
   200	            _inW,
   201	                (_) => List<double>.filled(3, 0.0),
   202	            growable: false,
   203	          ),
   204	          growable: false,
   205	        ),
   206	        growable: false,
   207	      );
   208	    }
   209	
   210	    final input = _inputBuffer!;
   211	    for (int y = 0; y < _inH; y++) {
   212	      for (int x = 0; x < _inW; x++) {
   213	        final px = letter.getPixel(x, y);
   214	        input[0][y][x][0] = px.r / 255.0;
   215	        input[0][y][x][1] = px.g / 255.0;
   216	        input[0][y][x][2] = px.b / 255.0;
   217	      }
   218	    }
   219	
   220	    if (_outputBuffers == null) {
   221	      _outputBuffers = <int, Object>{};
   222	      for (int i = 0; i < _outShapes.length; i++) {
   223	        final shape = _outShapes[i];
   224	        Object buf;
   225	        if (shape.length == 3) {
   226	          buf = List.generate(
   227	            shape[0],
   228	                (_) => List.generate(
   229	              shape[1],
   230	                  (_) => List<double>.filled(shape[2], 0.0),
   231	              growable: false,
   232	            ),
   233	            growable: false,
   234	          );
   235	        } else if (shape.length == 2) {
   236	          buf = List.generate(
   237	            shape[0],
   238	                (_) => List<double>.filled(shape[1], 0.0),
   239	            growable: false,
   240	          );
   241	        } else {
   242	          buf = List.filled(shape.reduce((a, b) => a * b), 0.0);
   243	        }
   244	        _outputBuffers![i] = buf;
   245	      }
   246	    }
   247	
   248	    final outputs = _outputBuffers!;
   249	
   250	    _interpreter!.runForMultipleInputs([input], outputs);
   251	
   252	    final decoded = _decodeAnyYoloOutputs(outputs.values.toList());
   253	
   254	    final scores = <double>[];
   255	    final clsIds = <int>[];
   256	    final xywhs = <List<double>>[];
   257	
   258	    for (final row in decoded) {
   259	      final C = row['C'] as int;
   260	      final xywh = (row['xywh'] as List).map((v) => (v as num).toDouble()).toList();
   261	      final rest = (row['rest'] as List).map((v) => (v as num).toDouble()).toList();
   262	
   263	      if (C == 84) {
   264	        int argMax = 0;
   265	        double best = -1e9;
   266	        for (int i = 0; i < rest.length; i++) {
   267	          final s = _sigmoid(rest[i]);
   268	          if (s > best) {
   269	            best = s;
   270	            argMax = i;
   271	          }
   272	        }
   273	        scores.add(best);
   274	        clsIds.add(argMax);
   275	        xywhs.add(xywh);
   276	      } else {
   277	        final obj = _sigmoid(rest[0]);
   278	        final clsLogits = rest.sublist(1, 81);
   279	        int argMax = 0;
   280	        double best = -1e9;
   281	        for (int i = 0; i < clsLogits.length; i++) {
   282	          final s = _sigmoid(clsLogits[i]);
   283	          if (s > best) {
   284	            best = s;
   285	            argMax = i;
   286	          }
   287	        }
   288	        scores.add(obj * best);
   289	        clsIds.add(argMax);
   290	        xywhs.add(xywh);
   291	      }
   292	    }
   293	
   294	    final keep0 = <int>[];
   295	    for (int i = 0; i < scores.length; i++) {
   296	      if (scores[i] >= confThres) keep0.add(i);
   297	    }
   298	    if (keep0.isEmpty) return <YoloDetection>[];
   299	
   300	    final keptXywh = [for (final i in keep0) xywhs[i]];
   301	    final keptCls = [for (final i in keep0) clsIds[i]];
   302	    final keptScore = [for (final i in keep0) scores[i]];
   303	
   304	    if (keptXywh.isNotEmpty && _median([for (final v in keptXywh) v[2]]) <= 2.0) {
   305	      for (final v in keptXywh) {
   306	        v[0] *= _inW.toDouble();
   307	        v[1] *= _inH.toDouble();
   308	        v[2] *= _inW.toDouble();
   309	        v[3] *= _inH.toDouble();
   310	      }
   311	    }
   312	
   313	    final boxesLtr = [for (final v in keptXywh) _xywhToXyxy(v)];
   314	    final boxes = <List<double>>[];
   315	    for (final b in boxesLtr) {
   316	      boxes.add(ImageUtils.scaleFromLetterbox(b, r, dw, dh));
   317	    }
   318	    final iw = image.width.toDouble();
   319	    final ih = image.height.toDouble();
   320	    for (final b in boxes) {
   321	      b[0] = b[0].clamp(0.0, iw);
   322	      b[2] = b[2].clamp(0.0, iw);
   323	      b[1] = b[1].clamp(0.0, ih);
   324	      b[3] = b[3].clamp(0.0, ih);
   325	    }
   326	
   327	    if (topkPreNms > 0 && keptScore.length > topkPreNms) {
   328	      final ord = _argSortDesc(keptScore).take(topkPreNms).toList();
   329	      final _boxes = <List<double>>[];
   330	      final _scores = <double>[];
   331	      final _cls = <int>[];
   332	      for (final i in ord) {
   333	        _boxes.add(boxes[i]);
   334	        _scores.add(keptScore[i]);
   335	        _cls.add(keptCls[i]);
   336	      }
   337	      boxes
   338	        ..clear()
   339	        ..addAll(_boxes);
   340	      keptScore
   341	        ..clear()
   342	        ..addAll(_scores);
   343	      keptCls
   344	        ..clear()
   345	        ..addAll(_cls);
   346	    }
   347	
   348	    if (personOnly) {
   349	      final fBoxes = <List<double>>[];
   350	      final fScores = <double>[];
   351	      final fCls = <int>[];
   352	      for (int i = 0; i < keptCls.length; i++) {
   353	        if (keptCls[i] == cocoPersonClassId) {
   354	          fBoxes.add(boxes[i]);
   355	          fScores.add(keptScore[i]);
   356	          fCls.add(keptCls[i]);
   357	        }
   358	      }
   359	      boxes
   360	        ..clear()
   361	        ..addAll(fBoxes);
   362	      keptScore
   363	        ..clear()
   364	        ..addAll(fScores);
   365	      keptCls
   366	        ..clear()
   367	        ..addAll(fCls);
   368	    }
   369	
   370	    final keep = _nms(boxes, keptScore, iouThres: iouThres, maxDet: maxDet);
   371	
   372	    final out = <YoloDetection>[];
   373	    for (final i in keep) {
   374	      out.add(YoloDetection(
   375	        cls: keptCls[i],
   376	        score: keptScore[i],
   377	        bboxXYXY: boxes[i],
   378	      ));
   379	    }
   380	    return out;
   381	  }
   382	}

// ========== lib/src/person_detector.dart ==========

     1	import 'dart:math' as math;
     2	import 'package:image/image.dart' as img;
     3	import 'package:tflite_flutter_custom/tflite_flutter.dart';
     4	import 'image_utils.dart';
     5	
     6	class YoloDetection {
     7	  final int cls;
     8	  final double score;
     9	  final List<double> bboxXYXY;
    10	
    11	  YoloDetection({
    12	    required this.cls,
    13	    required this.score,
    14	    required this.bboxXYXY,
    15	  });
    16	}
    17	
    18	class YoloV8PersonDetector {
    19	  static const int cocoPersonClassId = 0;
    20	
    21	  Interpreter? _interpreter;
    22	  bool _isInitialized = false;
    23	
    24	  late int _inW;
    25	  late int _inH;
    26	
    27	  final _outShapes = <List<int>>[];
    28	
    29	  List<List<List<List<double>>>>? _inputBuffer;
    30	  Map<int, Object>? _outputBuffers;
    31	
    32	  Future<void> initialize() async {
    33	    const assetPath = 'packages/pose_detection_tflite/assets/models/yolov8n_float32.tflite';
    34	    if (_isInitialized) await dispose();
    35	    _interpreter = await Interpreter.fromAsset(assetPath);
    36	    _interpreter!.allocateTensors();
    37	
    38	    final inTensor = _interpreter!.getInputTensor(0);
    39	    final inShape = inTensor.shape;
    40	    _inH = inShape[1];
    41	    _inW = inShape[2];
    42	
    43	    _outShapes.clear();
    44	    final outs = _interpreter!.getOutputTensors();
    45	    for (final t in outs) {
    46	      _outShapes.add(List<int>.from(t.shape));
    47	    }
    48	
    49	    _isInitialized = true;
    50	  }
    51	
    52	  bool get isInitialized => _isInitialized;
    53	
    54	  Future<void> dispose() async {
    55	    _interpreter?.close();
    56	    _interpreter = null;
    57	    _inputBuffer = null;
    58	    _outputBuffers = null;
    59	    _isInitialized = false;
    60	  }
    61	
    62	  static double _sigmoid(double x) => 1.0 / (1.0 + math.exp(-x));
    63	
    64	  static List<int> _argSortDesc(List<double> a) {
    65	    final idx = List<int>.generate(a.length, (i) => i);
    66	    idx.sort((i, j) => a[j].compareTo(a[i]));
    67	    return idx;
    68	  }
    69	
    70	  static List<int> _nms(
    71	      List<List<double>> boxes,
    72	      List<double> scores, {
    73	        double iouThres = 0.45,
    74	        int maxDet = 100,
    75	      }) {
    76	    if (boxes.isEmpty) return <int>[];
    77	    final order = _argSortDesc(scores);
    78	    final keep = <int>[];
    79	
    80	    double interArea(List<double> a, List<double> b) {
    81	      final xx1 = math.max(a[0], b[0]);
    82	      final yy1 = math.max(a[1], b[1]);
    83	      final xx2 = math.min(a[2], b[2]);
    84	      final yy2 = math.min(a[3], b[3]);
    85	      final w = math.max(0.0, xx2 - xx1);
    86	      final h = math.max(0.0, yy2 - yy1);
    87	      return w * h;
    88	    }
    89	
    90	    double area(List<double> b) => math.max(0.0, b[2] - b[0]) * math.max(0.0, b[3] - b[1]);
    91	    final areas = boxes.map(area).toList();
    92	
    93	    final suppressed = List<bool>.filled(order.length, false);
    94	    for (int m = 0; m < order.length; m++) {
    95	      if (suppressed[m]) continue;
    96	      final i = order[m];
    97	      keep.add(i);
    98	      if (keep.length >= maxDet) break;
    99	      for (int n = m + 1; n < order.length; n++) {
   100	        if (suppressed[n]) continue;
   101	        final j = order[n];
   102	        final inter = interArea(boxes[i], boxes[j]);
   103	        final u = areas[i] + areas[j] - inter + 1e-7;
   104	        final iou = inter / u;
   105	        if (iou > iouThres) suppressed[n] = true;
   106	      }
   107	    }
   108	    return keep;
   109	  }
   110	
   111	  static List<List<double>> _transpose2D(List<List<double>> a) {
   112	    if (a.isEmpty) return <List<double>>[];
   113	    final rows = a.length, cols = a[0].length;
   114	    final out = List.generate(cols, (_) => List<double>.filled(rows, 0.0));
   115	    for (int r = 0; r < rows; r++) {
   116	      final row = a[r];
   117	      for (int c = 0; c < cols; c++) {
   118	        out[c][r] = row[c];
   119	      }
   120	    }
   121	    return out;
   122	  }
   123	
   124	  static List<List<double>> _concat0(List<List<List<double>>> parts) {
   125	    final out = <List<double>>[];
   126	    for (final p in parts) {
   127	      out.addAll(p);
   128	    }
   129	    return out;
   130	  }
   131	
   132	  static List<List<double>> _ensure2D(List<dynamic> raw) {
   133	    return raw.map<List<double>>((e) => (e as List).map((v) => (v as num).toDouble()).toList()).toList();
   134	  }
   135	
   136	  List<Map<String, dynamic>> _decodeAnyYoloOutputs(List<dynamic> outputs) {
   137	    final parts = <List<List<double>>>[];
   138	    for (final raw in outputs) {
   139	      final t3d = raw as List;
   140	      if (t3d.length != 1) throw StateError('Unexpected YOLO output rank');
   141	      final out2d = _ensure2D(t3d[0]);
   142	      if (out2d.isEmpty) continue;
   143	      final rows = out2d.length;
   144	      final cols = out2d[0].length;
   145	      if (rows < cols && (rows == 84 || rows == 85)) {
   146	        parts.add(_transpose2D(out2d));
   147	      } else {
   148	        parts.add(out2d);
   149	      }
   150	    }
   151	    final out = _concat0(parts);
   152	    if (out.isEmpty || out[0].length < 84) throw StateError('Expected channels >=84');
   153	    final channels = out[0].length;
   154	    return out
   155	        .map((row) => {
   156	      'xywh': row.sublist(0, 4),
   157	      'rest': row.sublist(4),
   158	      'C': channels,
   159	    })
   160	        .toList();
   161	  }
   162	
   163	  static List<double> _xywhToXyxy(List<double> xywh) {
   164	    final cx = xywh[0], cy = xywh[1], w = xywh[2], h = xywh[3];
   165	    return [cx - w / 2.0, cy - h / 2.0, cx + w / 2.0, cy + h / 2.0];
   166	  }
   167	
   168	  static double _median(List<double> a) {
   169	    if (a.isEmpty) return double.nan;
   170	    final b = List<double>.from(a)..sort();
   171	    final n = b.length;
   172	    if (n.isOdd) return b[n ~/ 2];
   173	    return 0.5 * (b[n ~/ 2 - 1] + b[n ~/ 2]);
   174	  }
   175	
   176	  List<YoloDetection> detectOnImage(
   177	      img.Image image, {
   178	        double confThres = 0.35,
   179	        double iouThres = 0.4,
   180	        int topkPreNms = 100,
   181	        int maxDet = 10,
   182	        bool personOnly = true,
   183	      }) {
   184	    if (!_isInitialized || _interpreter == null) {
   185	      throw StateError('YoloV8PersonDetector not initialized.');
   186	    }
   187	
   188	    final ratio = <double>[];
   189	    final dwdh = <int>[];
   190	    final letter = ImageUtils.letterbox(image, _inW, _inH, ratio, dwdh);
   191	    final r = ratio.first;
   192	    final dw = dwdh[0], dh = dwdh[1];
   193	
   194	    if (_inputBuffer == null) {
   195	      _inputBuffer = List.generate(
   196	        1,
   197	            (_) => List.generate(
   198	          _inH,
   199	              (_) => List.generate(
   200	            _inW,
   201	                (_) => List<double>.filled(3, 0.0),
   202	            growable: false,
   203	          ),
   204	          growable: false,
   205	        ),
   206	        growable: false,
   207	      );
   208	    }
   209	
   210	    final input = _inputBuffer!;
   211	    for (int y = 0; y < _inH; y++) {
   212	      for (int x = 0; x < _inW; x++) {
   213	        final px = letter.getPixel(x, y);
   214	        input[0][y][x][0] = px.r / 255.0;
   215	        input[0][y][x][1] = px.g / 255.0;
   216	        input[0][y][x][2] = px.b / 255.0;
   217	      }
   218	    }
   219	
   220	    if (_outputBuffers == null) {
   221	      _outputBuffers = <int, Object>{};
   222	      for (int i = 0; i < _outShapes.length; i++) {
   223	        final shape = _outShapes[i];
   224	        Object buf;
   225	        if (shape.length == 3) {
   226	          buf = List.generate(
   227	            shape[0],
   228	                (_) => List.generate(
   229	              shape[1],
   230	                  (_) => List<double>.filled(shape[2], 0.0),
   231	              growable: false,
   232	            ),
   233	            growable: false,
   234	          );
   235	        } else if (shape.length == 2) {
   236	          buf = List.generate(
   237	            shape[0],
   238	                (_) => List<double>.filled(shape[1], 0.0),
   239	            growable: false,
   240	          );
   241	        } else {
   242	          buf = List.filled(shape.reduce((a, b) => a * b), 0.0);
   243	        }
   244	        _outputBuffers![i] = buf;
   245	      }
   246	    }
   247	
   248	    final outputs = _outputBuffers!;
   249	
   250	    _interpreter!.runForMultipleInputs([input], outputs);
   251	
   252	    final decoded = _decodeAnyYoloOutputs(outputs.values.toList());
   253	
   254	    final scores = <double>[];
   255	    final clsIds = <int>[];
   256	    final xywhs = <List<double>>[];
   257	
   258	    for (final row in decoded) {
   259	      final C = row['C'] as int;
   260	      final xywh = (row['xywh'] as List).map((v) => (v as num).toDouble()).toList();
   261	      final rest = (row['rest'] as List).map((v) => (v as num).toDouble()).toList();
   262	
   263	      if (C == 84) {
   264	        int argMax = 0;
   265	        double best = -1e9;
   266	        for (int i = 0; i < rest.length; i++) {
   267	          final s = _sigmoid(rest[i]);
   268	          if (s > best) {
   269	            best = s;
   270	            argMax = i;
   271	          }
   272	        }
   273	        scores.add(best);
   274	        clsIds.add(argMax);
   275	        xywhs.add(xywh);
   276	      } else {
   277	        final obj = _sigmoid(rest[0]);
   278	        final clsLogits = rest.sublist(1, 81);
   279	        int argMax = 0;
   280	        double best = -1e9;
   281	        for (int i = 0; i < clsLogits.length; i++) {
   282	          final s = _sigmoid(clsLogits[i]);
   283	          if (s > best) {
   284	            best = s;
   285	            argMax = i;
   286	          }
   287	        }
   288	        scores.add(obj * best);
   289	        clsIds.add(argMax);
   290	        xywhs.add(xywh);
   291	      }
   292	    }
   293	
   294	    final keep0 = <int>[];
   295	    for (int i = 0; i < scores.length; i++) {
   296	      if (scores[i] >= confThres) keep0.add(i);
   297	    }
   298	    if (keep0.isEmpty) return <YoloDetection>[];
   299	
   300	    final keptXywh = [for (final i in keep0) xywhs[i]];
   301	    final keptCls = [for (final i in keep0) clsIds[i]];
   302	    final keptScore = [for (final i in keep0) scores[i]];
   303	
   304	    if (keptXywh.isNotEmpty && _median([for (final v in keptXywh) v[2]]) <= 2.0) {
   305	      for (final v in keptXywh) {
   306	        v[0] *= _inW.toDouble();
   307	        v[1] *= _inH.toDouble();
   308	        v[2] *= _inW.toDouble();
   309	        v[3] *= _inH.toDouble();
   310	      }
   311	    }
   312	
   313	    final boxesLtr = [for (final v in keptXywh) _xywhToXyxy(v)];
   314	    final boxes = <List<double>>[];
   315	    for (final b in boxesLtr) {
   316	      boxes.add(ImageUtils.scaleFromLetterbox(b, r, dw, dh));
   317	    }
   318	    final iw = image.width.toDouble();
   319	    final ih = image.height.toDouble();
   320	    for (final b in boxes) {
   321	      b[0] = b[0].clamp(0.0, iw);
   322	      b[2] = b[2].clamp(0.0, iw);
   323	      b[1] = b[1].clamp(0.0, ih);
   324	      b[3] = b[3].clamp(0.0, ih);
   325	    }
   326	
   327	    if (topkPreNms > 0 && keptScore.length > topkPreNms) {
   328	      final ord = _argSortDesc(keptScore).take(topkPreNms).toList();
   329	      final _boxes = <List<double>>[];
   330	      final _scores = <double>[];
   331	      final _cls = <int>[];
   332	      for (final i in ord) {
   333	        _boxes.add(boxes[i]);
   334	        _scores.add(keptScore[i]);
   335	        _cls.add(keptCls[i]);
   336	      }
   337	      boxes
   338	        ..clear()
   339	        ..addAll(_boxes);
   340	      keptScore
   341	        ..clear()
   342	        ..addAll(_scores);
   343	      keptCls
   344	        ..clear()
   345	        ..addAll(_cls);
   346	    }
   347	
   348	    if (personOnly) {
   349	      final fBoxes = <List<double>>[];
   350	      final fScores = <double>[];
   351	      final fCls = <int>[];
   352	      for (int i = 0; i < keptCls.length; i++) {
   353	        if (keptCls[i] == cocoPersonClassId) {
   354	          fBoxes.add(boxes[i]);
   355	          fScores.add(keptScore[i]);
   356	          fCls.add(keptCls[i]);
   357	        }
   358	      }
   359	      boxes
   360	        ..clear()
   361	        ..addAll(fBoxes);
   362	      keptScore
   363	        ..clear()
   364	        ..addAll(fScores);
   365	      keptCls
   366	        ..clear()
   367	        ..addAll(fCls);
   368	    }
   369	
   370	    final keep = _nms(boxes, keptScore, iouThres: iouThres, maxDet: maxDet);
   371	
   372	    final out = <YoloDetection>[];
   373	    for (final i in keep) {
   374	      out.add(YoloDetection(
   375	        cls: keptCls[i],
   376	        score: keptScore[i],
   377	        bboxXYXY: boxes[i],
   378	      ));
   379	    }
   380	    return out;
   381	  }
   382	}

// ========== lib/src/pose_detector.dart ==========

     1	import 'dart:typed_data';
     2	import 'package:image/image.dart' as img;
     3	import 'types.dart';
     4	import 'image_utils.dart';
     5	import 'person_detector.dart';
     6	import 'pose_landmark_model.dart';
     7	
     8	class PoseDetector {
     9	  bool _isInitialized = false;
    10	  late PoseOptions _opts;
    11	
    12	  final YoloV8PersonDetector _yolo = YoloV8PersonDetector();
    13	  final PoseLandmarkModelRunner _lm = PoseLandmarkModelRunner();
    14	
    15	  Future<void> initialize({PoseOptions options = const PoseOptions()}) async {
    16	    if (_isInitialized) {
    17	      await dispose();
    18	    }
    19	    _opts = options;
    20	    await _lm.initialize(_opts.landmarkModel);
    21	    await _yolo.initialize();
    22	    _isInitialized = true;
    23	  }
    24	
    25	  bool get isInitialized => _isInitialized;
    26	
    27	  Future<void> dispose() async {
    28	    await _yolo.dispose();
    29	    await _lm.dispose();
    30	    _isInitialized = false;
    31	  }
    32	
    33	  Future<List<PoseResult>> detect(List<int> imageBytes) async {
    34	    if (!_isInitialized) {
    35	      throw StateError('PoseDetector not initialized. Call initialize() first.');
    36	    }
    37	    final image = img.decodeImage(Uint8List.fromList(imageBytes));
    38	    if (image == null) return <PoseResult>[];
    39	    return detectOnImage(image);
    40	  }
    41	
    42	  Future<List<PoseResult>> detectOnImage(img.Image image) async {
    43	    if (!_isInitialized) {
    44	      throw StateError('PoseDetector not initialized. Call initialize() first.');
    45	    }
    46	
    47	    final dets = _yolo.detectOnImage(
    48	      image,
    49	      confThres: _opts.detectorConf,
    50	      iouThres: _opts.detectorIou,
    51	      topkPreNms: 100,
    52	      maxDet: _opts.maxDetections,
    53	      personOnly: true,
    54	    );
    55	
    56	    if (_opts.mode == PoseMode.boxes) {
    57	      final out = <PoseResult>[];
    58	      for (final d in dets) {
    59	        out.add(
    60	          PoseResult(
    61	            bboxPx: RectPx(
    62	              left: d.bboxXYXY[0],
    63	              top: d.bboxXYXY[1],
    64	              right: d.bboxXYXY[2],
    65	              bottom: d.bboxXYXY[3],
    66	            ),
    67	            score: d.score,
    68	            landmarks: null,
    69	            imageWidth: image.width,
    70	            imageHeight: image.height,
    71	          ),
    72	        );
    73	      }
    74	      return out;
    75	    }
    76	
    77	    final results = <PoseResult>[];
    78	    for (final d in dets) {
    79	      final x1 = d.bboxXYXY[0].clamp(0.0, image.width.toDouble()).toInt();
    80	      final y1 = d.bboxXYXY[1].clamp(0.0, image.height.toDouble()).toInt();
    81	      final x2 = d.bboxXYXY[2].clamp(0.0, image.width.toDouble()).toInt();
    82	      final y2 = d.bboxXYXY[3].clamp(0.0, image.height.toDouble()).toInt();
    83	      final cw = (x2 - x1).clamp(1, image.width);
    84	      final ch = (y2 - y1).clamp(1, image.height);
    85	
    86	      final crop = img.copyCrop(image, x: x1, y: y1, width: cw, height: ch);
    87	      final ratio = <double>[];
    88	      final dwdh = <int>[];
    89	      final letter = ImageUtils.letterbox256(crop, ratio, dwdh);
    90	      final r = ratio.first;
    91	      final dw = dwdh[0];
    92	      final dh = dwdh[1];
    93	
    94	      final lms = _lm.run(letter);
    95	      if (lms.score < _opts.minLandmarkScore) continue;
    96	
    97	      final pts = <PoseLandmark>[];
    98	      for (final lm in lms.landmarks) {
    99	        final xp = lm.x * 256.0;
   100	        final yp = lm.y * 256.0;
   101	        final xContent = (xp - dw) / r;
   102	        final yContent = (yp - dh) / r;
   103	        final xOrig = (x1.toDouble() + xContent).clamp(0.0, image.width.toDouble());
   104	        final yOrig = (y1.toDouble() + yContent).clamp(0.0, image.height.toDouble());
   105	        pts.add(
   106	          PoseLandmark(
   107	            type: lm.type,
   108	            x: xOrig,
   109	            y: yOrig,
   110	            z: lm.z,
   111	            visibility: lm.visibility,
   112	          ),
   113	        );
   114	      }
   115	
   116	      results.add(
   117	        PoseResult(
   118	          bboxPx: RectPx(
   119	            left: d.bboxXYXY[0],
   120	            top: d.bboxXYXY[1],
   121	            right: d.bboxXYXY[2],
   122	            bottom: d.bboxXYXY[3],
   123	          ),
   124	          score: d.score,
   125	          landmarks: pts,
   126	          imageWidth: image.width,
   127	          imageHeight: image.height,
   128	        ),
   129	      );
   130	    }
   131	
   132	    return results;
   133	  }
   134	}

// ========== lib/src/pose_landmark_model.dart ==========

     1	import 'dart:ffi' as ffi;
     2	import 'dart:io';
     3	import 'dart:math' as math;
     4	import 'package:image/image.dart' as img;
     5	import 'package:path/path.dart' as p;
     6	import 'package:tflite_flutter_custom/tflite_flutter.dart';
     7	import 'image_utils.dart';
     8	import 'types.dart';
     9	
    10	class PoseLandmarkModelRunner {
    11	  Interpreter? _interpreter;
    12	  bool _isInitialized = false;
    13	
    14	  static ffi.DynamicLibrary? _tfliteLib;
    15	
    16	  List<List<List<List<double>>>>? _inputBuffer;
    17	  List<List<double>>? _outputLandmarks;
    18	  List<List<double>>? _outputScore;
    19	  List<List<List<List<double>>>>? _outputMask;
    20	  List<List<List<List<double>>>>? _outputHeatmap;
    21	  List<List<double>>? _outputWorld;
    22	
    23	  static Future<void> ensureTFLiteLoaded() async {
    24	    if (_tfliteLib != null) return;
    25	
    26	    final exe = File(Platform.resolvedExecutable);
    27	    final exeDir = exe.parent;
    28	
    29	    late final List<String> candidates;
    30	
    31	    if (Platform.isWindows) {
    32	      candidates = [
    33	        p.join(exeDir.path, 'libtensorflowlite_c-win.dll'),
    34	        'libtensorflowlite_c-win.dll',
    35	      ];
    36	    } else if (Platform.isLinux) {
    37	      candidates = [
    38	        p.join(exeDir.path, 'lib', 'libtensorflowlite_c-linux.so'),
    39	        'libtensorflowlite_c-linux.so',
    40	      ];
    41	    } else if (Platform.isMacOS) {
    42	      final contents = exeDir.parent;
    43	      candidates = [
    44	        p.join(contents.path, 'Resources', 'libtensorflowlite_c-mac.dylib'),
    45	      ];
    46	    } else {
    47	      _tfliteLib = ffi.DynamicLibrary.process();
    48	      return;
    49	    }
    50	
    51	    for (final c in candidates) {
    52	      try {
    53	        if (c.contains(p.separator)) {
    54	          if (!File(c).existsSync()) continue;
    55	        }
    56	        _tfliteLib = ffi.DynamicLibrary.open(c);
    57	        return;
    58	      } catch (_) {}
    59	    }
    60	  }
    61	
    62	  Future<void> initialize(PoseLandmarkModel model) async {
    63	    if (_isInitialized) await dispose();
    64	    await ensureTFLiteLoaded();
    65	
    66	    final path = _getModelPath(model);
    67	    _interpreter = await Interpreter.fromAsset(path);
    68	    _interpreter!.resizeInputTensor(0, [1, 256, 256, 3]);
    69	    _interpreter!.allocateTensors();
    70	
    71	    _isInitialized = true;
    72	  }
    73	
    74	  String _getModelPath(PoseLandmarkModel model) {
    75	    switch (model) {
    76	      case PoseLandmarkModel.lite:
    77	        return 'packages/pose_detection_tflite/assets/models/pose_landmark_lite.tflite';
    78	      case PoseLandmarkModel.full:
    79	        return 'packages/pose_detection_tflite/assets/models/pose_landmark_full.tflite';
    80	      case PoseLandmarkModel.heavy:
    81	        return 'packages/pose_detection_tflite/assets/models/pose_landmark_heavy.tflite';
    82	    }
    83	  }
    84	
    85	  bool get isInitialized => _isInitialized;
    86	
    87	  Future<void> dispose() async {
    88	    _interpreter?.close();
    89	    _interpreter = null;
    90	    _inputBuffer = null;
    91	    _outputLandmarks = null;
    92	    _outputScore = null;
    93	    _outputMask = null;
    94	    _outputHeatmap = null;
    95	    _outputWorld = null;
    96	    _isInitialized = false;
    97	  }
    98	
    99	  PoseLandmarks run(img.Image roiImage) {
   100	    _inputBuffer = ImageUtils.imageToNHWC4D(roiImage, 256, 256, reuse: _inputBuffer);
   101	
   102	    _outputLandmarks ??= [List.filled(195, 0.0)];
   103	    _outputScore ??= [[0.0]];
   104	    _outputMask ??= ImageUtils.reshapeToTensor4D(
   105	      List.filled(1 * 256 * 256 * 1, 0.0),
   106	      1,
   107	      256,
   108	      256,
   109	      1,
   110	    );
   111	    _outputHeatmap ??= ImageUtils.reshapeToTensor4D(
   112	      List.filled(1 * 64 * 64 * 39, 0.0),
   113	      1,
   114	      64,
   115	      64,
   116	      39,
   117	    );
   118	    _outputWorld ??= [List.filled(117, 0.0)];
   119	
   120	    _interpreter!.runForMultipleInputs(
   121	      [_inputBuffer!],
   122	      {
   123	        0: _outputLandmarks!,
   124	        1: _outputScore!,
   125	        2: _outputMask!,
   126	        3: _outputHeatmap!,
   127	        4: _outputWorld!,
   128	      },
   129	    );
   130	
   131	    return _parseLandmarks(_outputLandmarks!, _outputScore!, _outputWorld!);
   132	  }
   133	
   134	  PoseLandmarks _parseLandmarks(
   135	      List<dynamic> landmarksData,
   136	      List<dynamic> scoreData,
   137	      List<dynamic> worldData,
   138	      ) {
   139	    double sigmoid(double x) => 1.0 / (1.0 + math.exp(-x));
   140	    double clamp01(double v) => v.isNaN ? 0.0 : v < 0.0 ? 0.0 : (v > 1.0 ? 1.0 : v);
   141	
   142	    final score = sigmoid(scoreData[0][0] as double);
   143	    final raw = landmarksData[0] as List<dynamic>;
   144	    final lm = <PoseLandmark>[];
   145	
   146	    for (int i = 0; i < 33; i++) {
   147	      final base = i * 5;
   148	      final x = clamp01((raw[base + 0] as double) / 256.0);
   149	      final y = clamp01((raw[base + 1] as double) / 256.0);
   150	      final z = raw[base + 2] as double;
   151	      final visibility = sigmoid(raw[base + 3] as double);
   152	      final presence = sigmoid(raw[base + 4] as double);
   153	      final vis = (visibility * presence).clamp(0.0, 1.0);
   154	
   155	      lm.add(
   156	        PoseLandmark(
   157	          type: PoseLandmarkType.values[i],
   158	          x: x,
   159	          y: y,
   160	          z: z,
   161	          visibility: vis,
   162	        ),
   163	      );
   164	    }
   165	
   166	    return PoseLandmarks(landmarks: lm, score: score);
   167	  }
   168	}

// ========== lib/src/types.dart ==========

     1	import 'dart:math' as math;
     2	
     3	enum PoseLandmarkModel { lite, full, heavy }
     4	
     5	enum PoseMode { boxes, boxesAndLandmarks }
     6	
     7	class PoseOptions {
     8	  final PoseMode mode;
     9	  final PoseLandmarkModel landmarkModel;
    10	  final double detectorConf;
    11	  final double detectorIou;
    12	  final int maxDetections;
    13	  final double minLandmarkScore;
    14	
    15	  const PoseOptions({
    16	    this.mode = PoseMode.boxesAndLandmarks,
    17	    this.landmarkModel = PoseLandmarkModel.heavy,
    18	    this.detectorConf = 0.5,
    19	    this.detectorIou = 0.45,
    20	    this.maxDetections = 10,
    21	    this.minLandmarkScore = 0.5,
    22	  });
    23	}
    24	
    25	class PoseLandmarks {
    26	  final List<PoseLandmark> landmarks;
    27	  final double score;
    28	
    29	  PoseLandmarks({
    30	    required this.landmarks,
    31	    required this.score,
    32	  });
    33	}
    34	
    35	class PoseLandmark {
    36	  final PoseLandmarkType type;
    37	  final double x;
    38	  final double y;
    39	  final double z;
    40	  final double visibility;
    41	
    42	  PoseLandmark({
    43	    required this.type,
    44	    required this.x,
    45	    required this.y,
    46	    required this.z,
    47	    required this.visibility,
    48	  });
    49	
    50	  double xNorm(int imageWidth) => (x / imageWidth).clamp(0.0, 1.0);
    51	  double yNorm(int imageHeight) => (y / imageHeight).clamp(0.0, 1.0);
    52	
    53	  Point toPixel(int imageWidth, int imageHeight) {
    54	    return Point(x.toInt(), y.toInt());
    55	  }
    56	}
    57	
    58	enum PoseLandmarkType {
    59	  nose,
    60	  leftEyeInner,
    61	  leftEye,
    62	  leftEyeOuter,
    63	  rightEyeInner,
    64	  rightEye,
    65	  rightEyeOuter,
    66	  leftEar,
    67	  rightEar,
    68	  mouthLeft,
    69	  mouthRight,
    70	  leftShoulder,
    71	  rightShoulder,
    72	  leftElbow,
    73	  rightElbow,
    74	  leftWrist,
    75	  rightWrist,
    76	  leftPinky,
    77	  rightPinky,
    78	  leftIndex,
    79	  rightIndex,
    80	  leftThumb,
    81	  rightThumb,
    82	  leftHip,
    83	  rightHip,
    84	  leftKnee,
    85	  rightKnee,
    86	  leftAnkle,
    87	  rightAnkle,
    88	  leftHeel,
    89	  rightHeel,
    90	  leftFootIndex,
    91	  rightFootIndex,
    92	}
    93	
    94	class Point {
    95	  final int x;
    96	  final int y;
    97	
    98	  Point(this.x, this.y);
    99	}
   100	
   101	class RectPx {
   102	  final double left;
   103	  final double top;
   104	  final double right;
   105	  final double bottom;
   106	
   107	  const RectPx({
   108	    required this.left,
   109	    required this.top,
   110	    required this.right,
   111	    required this.bottom,
   112	  });
   113	}
   114	
   115	class PoseResult {
   116	  final RectPx bboxPx;
   117	  final double score;
   118	  final List<PoseLandmark>? landmarks;
   119	  final int imageWidth;
   120	  final int imageHeight;
   121	
   122	  const PoseResult({
   123	    required this.bboxPx,
   124	    required this.score,
   125	    required this.landmarks,
   126	    required this.imageWidth,
   127	    required this.imageHeight,
   128	  });
   129	
   130	  PoseLandmark? getLandmark(PoseLandmarkType type) {
   131	    if (landmarks == null) return null;
   132	    try {
   133	      return landmarks!.firstWhere((l) => l.type == type);
   134	    } catch (_) {
   135	      return null;
   136	    }
   137	  }
   138	
   139	  bool get hasLandmarks => landmarks != null && landmarks!.isNotEmpty;
   140	
   141	  @override
   142	  String toString() {
   143	    final lm = landmarks ?? const <PoseLandmark>[];
   144	    final landmarksInfo = lm
   145	        .map((l) => '${l.type.name}: (${l.x.toStringAsFixed(2)}, ${l.y.toStringAsFixed(2)}) vis=${l.visibility.toStringAsFixed(2)}')
   146	        .join('\n');
   147	    return 'PoseResult(\n'
   148	        '  score=${score.toStringAsFixed(3)},\n'
   149	        '  landmarks=${lm.length},\n'
   150	        '  coords:\n$landmarksInfo\n)';
   151	  }
   152	}
